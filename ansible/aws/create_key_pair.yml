# Creates the ec2 Key Pair and downloads the cert to ~/.ssh.
#
# You can only download the cert for the key pair when you
# first create the key pair. So if you don't have the cert
# then you need to create a new key pair.
#
# This playbook will attempt to use your machines hostname
# as the name for the key pair and for the cert file in ~/.ssh.
#
# This will fail if you already have a cert in ~/.ssh. If
# that happens then run remove_key_pair.yml.

- hosts: local
  connection: local
  gather_facts: False
  vars_files:
    - vars/aws_vault.yml
    - vars/aws.yml

  tasks:
    - name: Get the hostnam of the control machine
      command: hostname
      register: hostname

    - name: Get the username of the current user
      command: whoami
      register: username

    - name: Ensure the ec2 Key Pair exists 
      ec2_key:
        name: "{{ hostname.stdout }}"
        profile: "{{ aws_profile_name }}"
        region: "{{ aws_region }}"
        aws_access_key: "{{ aws_access_key }}"
        aws_secret_key: "{{ aws_secret_key }}"
        security_token: "{{ aws_session_token }}"
      register: ec2_key_creation_result
      # FIXME: This play produces an error every time. The response is
      # 'InvalidKeyPair.Dupicate' whatever the key pair name is, even
      # if it's random. I don't know the cause so I'm disabling errors.
      ignore_errors: true
    - name: Debug key creation
      debug:
        var: ec2_key_creation_result
        verbosity: 2

    - name: The private key is save to a local .pem file
      copy: content="{{ ec2_key_creation_result.key.private_key }}" dest="~/.ssh/{{ hostname.stdout }}.pem" mode=0600
      when: ec2_key_creation_result.changed

    - stat:
        path: "~/.ssh/{{ hostname.stdout}}.pem"
      register: key_file_stat

    - fail:
        msg: This play ended and no cert is present!
      when: key_file_stat.stat.exists == False
